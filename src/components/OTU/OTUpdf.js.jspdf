import React, { useEffect, useState } from 'react';
import { jsPDF } from 'jspdf';
import { alphabetize, sort } from '../../util';

//This file was generated by CoPilot and Claude Sonnet 3.5 because, honestly, who would want to write this by hand? I used jsPDF instead of @react-pdf/renderer because I couldn't get that package to work with the Create React App baggage in this project. I'm going to experiment with porting to Vite so we can use react-pdf, but I'm putting this in the codebase in case we have to use it.

// PDF styles
const styles = {
    title: {
        fontSize: 24,
        y: 20
    },
    subtitle: {
        fontSize: 18
    },
    text: {
        fontSize: 12
    },
    label: {
        fontSize: 10,
        color: '#666666'
    }
};

export const OTUpdf = ({ data }) => {
    const [pdfGenerated, setPdfGenerated] = useState(false);
    const otus = data ? alphabetize([...data.OTU], "name") : [];

    useEffect(() => {
        // Skip if already generated or no data
        if (pdfGenerated || otus.length === 0) return;

        const generatePDF = async () => {
            if (otus.length > 0) {
                const doc = new jsPDF();
                let yOffset = 10;
                const margin = 20;

                // Helper functions for image processing
                const loadImage = async (img) => {
                    try {
                        const response = await fetch(img.link);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const blob = await response.blob();
                        if (blob.size === 0) {
                            throw new Error('Empty image blob received');
                        }
                        return await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onloadend = () => {
                                if (reader.result) {
                                    resolve(reader.result);
                                } else {
                                    reject(new Error('FileReader returned empty result'));
                                }
                            };
                            reader.onerror = (e) => reject(new Error(`FileReader error: ${e.message}`));
                            reader.readAsDataURL(blob);
                        });
                    } catch (error) {
                        console.error('Error loading image:', error);
                        console.error('Image URL:', img.link);
                        return null;
                    }
                };

                const calculateImageHeight = async (imageItem) => {
                    if (!imageItem) return 0;
                    const imageData = await loadImage(imageItem);
                    if (!imageData) return 25; // Height for error message
                    
                    const imgElement = new Image();
                    await new Promise((resolve) => {
                        imgElement.onload = resolve;
                        imgElement.src = imageData;
                    });

                    let finalHeight = imgElement.height;
                    const maxWidth = doc.internal.pageSize.width - (margin * 2);

                    if (imgElement.width > maxWidth) {
                        const ratio = maxWidth / imgElement.width;
                        finalHeight = finalHeight * ratio;
                    }

                    if (finalHeight > 120) {
                        finalHeight = 120;
                    }

                    return finalHeight + 25; // image height + caption + spacing
                };

                const processImage = async (imageItem) => {
                    try {
                        const imageData = await loadImage(imageItem);
                        if (imageData) {
                            // Load image to get dimensions first
                            const imgElement = new Image();
                            await new Promise((resolve, reject) => {
                                imgElement.onload = resolve;
                                imgElement.onerror = (e) => {
                                    console.error('Error loading image:', e);
                                    reject(e);
                                };
                                imgElement.src = imageData;
                            }).catch(e => {
                                throw new Error(`Failed to load image: ${e.message}`);
                            });

                            // Calculate dimensions maintaining aspect ratio
                            const pageWidth = doc.internal.pageSize.width;
                            const pageHeight = doc.internal.pageSize.height;
                            const maxWidth = pageWidth - (margin * 2);
                            const maxHeight = 120;

                            let finalWidth = imgElement.width;
                            let finalHeight = imgElement.height;

                            if (finalWidth > maxWidth) {
                                const ratio = maxWidth / finalWidth;
                                finalWidth = maxWidth;
                                finalHeight = finalHeight * ratio;
                            }

                            if (finalHeight > maxHeight) {
                                const ratio = maxHeight / finalHeight;
                                finalWidth = finalWidth * ratio;
                                finalHeight = maxHeight;
                            }

                            const captionHeight = 10;
                            const totalHeight = finalHeight + captionHeight;
                            
                            if (yOffset + totalHeight > pageHeight - 40) {
                                doc.addPage();
                                yOffset = 20;
                                doc.text(`${imageItem.caption}`, margin, yOffset);
                                yOffset += captionHeight;
                            } else {
                                doc.text(`${imageItem.caption}`, margin, yOffset);
                                yOffset += captionHeight;
                            }

                            doc.addImage(
                                imageData,
                                'JPEG',
                                margin,
                                yOffset,
                                finalWidth,
                                finalHeight,
                                undefined,
                                'MEDIUM'
                            );
                            yOffset += finalHeight + 15;

                        } else {
                            doc.text(`${imageItem.caption}`, margin, yOffset);
                            doc.text(`(Image unavailable - ${imageItem.link})`, margin + 10, yOffset + 5);
                            yOffset += 15;
                        }
                    } catch (error) {
                        console.error('Error processing image:', error);
                        doc.text(`${imageItem.caption}`, margin, yOffset);
                        doc.text(`(Error loading image)`, margin + 10, yOffset + 5);
                        yOffset += 15;
                    }
                };                                    // Process each OTU
                for (const otu of otus) {
                    const { 
                        pbotID, 
                        name, 
                        authority,
                        diagnosis,
                        qualityIndex,
                        majorTaxonGroup,
                        pbdbParentTaxon,
                        family,
                        genus,
                        species,
                        holotypeSpecimen,
                        typeSpecimens,
                        identifiedSpecimens,
                        mergedDescription,
                        synonyms,
                        elementOf,
                        notes,
                        partsPreserved,
                        notableFeatures,
                        enteredBy
                    } = otu;

                    // Basic Info Header
                    doc.setFontSize(styles.title.fontSize);
                    doc.text(name || "(name missing)", margin, yOffset + styles.title.y);
                    yOffset += 30;

                    // Key Information Section
                    const lineHeight = 10;
                    doc.setFontSize(styles.text.fontSize);

                    // Add all key information
                    doc.text(`PBOT ID: ${pbotID}`, margin, yOffset);
                    yOffset += 7;
                    
                    // Add links using window.location.origin
                    const directQParams = ["includeSynonyms", "includeComments", "includeHolotypeDescription", "includeMergedDescription"];
                    const jsonQParams = [...directQParams, "format=json"];
                    const pdfQParams = [...directQParams, "format=pdf"];
                    const directQueryString = directQParams.length > 0 ? `?${directQParams.join("&")}` : "";
                    const jsonQueryString = `?${jsonQParams.join("&")}`;
                    const pdfQueryString = `?${pdfQParams.join("&")}`;

                    // Create full URLs
                    const directUrl = `${window.location.origin}/query/otu/${pbotID}${directQueryString}`;
                    const jsonUrl = `${window.location.origin}/query/otu/${pbotID}${jsonQueryString}`;
                    const pdfUrl = `${window.location.origin}/query/otu/${pbotID}${pdfQueryString}`;

                    // Split long URLs to fit page width
                    const maxWidth = doc.internal.pageSize.width - (2 * margin);
                    const directLines = doc.splitTextToSize(`Direct Link: ${directUrl}`, maxWidth);
                    const jsonLines = doc.splitTextToSize(`JSON Link: ${jsonUrl}`, maxWidth);
                    const pdfLines = doc.splitTextToSize(`PDF Link: ${pdfUrl}`, maxWidth);

                    doc.text(directLines, margin, yOffset);
                    yOffset += (directLines.length * 7);
                    doc.text(jsonLines, margin, yOffset);
                    yOffset += (jsonLines.length * 7);
                    doc.text(pdfLines, margin, yOffset);
                    yOffset += (pdfLines.length * 7);
                    
                    doc.text(`Authority: ${authority || "N/A"}`, margin, yOffset);
                    yOffset += 7;
                    doc.text(`Quality Index: ${qualityIndex || "N/A"}`, margin, yOffset);
                    yOffset += 7;
                    doc.text(`Parts Preserved: ${partsPreserved?.map(p => p.type).join(", ") || "None"}`, margin, yOffset);
                    yOffset += 7;
                    doc.text(`Notable Features: ${notableFeatures?.map(f => f.name).join(", ") || "None"}`, margin, yOffset);
                    yOffset += 7;
                    
                    if (elementOf?.length > 0) {
                        doc.text(`Data Access Groups: ${elementOf.map(e => e.name).join(", ")}`, margin, yOffset);
                        yOffset += 7;
                    }
                    
                    yOffset += lineHeight; // Add padding after the gray box

                    // 1. Images Section

                    // Process images by section
                    const holotypeImages = holotypeSpecimen?.Specimen?.images || [];
                    const typeImages = (typeSpecimens || []).flatMap(ts => ts.Specimen?.images || []);
                    const identifiedImages = (identifiedSpecimens || []).flatMap(is => is.Specimen?.images || []);

                    if (holotypeImages.length > 0 || typeImages.length > 0 || identifiedImages.length > 0) {
                        // Helper function to ensure header stays with first image
                        const processImageSection = async (title, images, getCaption) => {
                            const headerHeight = 25; // Height for section header (includes margins)
                            const messageHeight = 10; // Height for "No images" message
                            const pageHeight = doc.internal.pageSize.height;
                            
                            // Calculate total needed height based on whether we have images
                            const neededHeight = images.length === 0 
                                ? headerHeight + messageHeight 
                                : headerHeight + await calculateImageHeight(images[0]);
                            
                            // Check if we need a new page
                            if (yOffset + neededHeight > pageHeight - 40) {
                                doc.addPage();
                                yOffset = 20;
                            }
                            
                            // Show the section header
                            doc.setFontSize(styles.subtitle.fontSize);
                            doc.text(title, margin + 10, yOffset);
                            yOffset += 15;
                            doc.setFontSize(styles.text.fontSize);

                            if (images.length === 0) {
                                doc.text(`No ${title.toLowerCase()} available`, margin, yOffset);
                                yOffset += 10;
                                return;
                            }
                            
                            // Calculate space needed for first image before writing header
                            let firstImageHeight = 0;
                            if (images[0]) {
                                const imageData = await loadImage(images[0]);
                                if (imageData) {
                                    const imgElement = new Image();
                                    await new Promise((resolve) => {
                                        imgElement.onload = resolve;
                                        imgElement.src = imageData;
                                    });

                                    let finalWidth = imgElement.width;
                                    let finalHeight = imgElement.height;
                                    const maxWidth = doc.internal.pageSize.width - (margin * 2);
                                    const maxHeight = 120;

                                    if (finalWidth > maxWidth) {
                                        const ratio = maxWidth / finalWidth;
                                        finalWidth = maxWidth;
                                        finalHeight = finalHeight * ratio;
                                    }

                                    if (finalHeight > maxHeight) {
                                        const ratio = maxHeight / finalHeight;
                                        finalHeight = maxHeight;
                                    }

                                    firstImageHeight = finalHeight + 25; // image height + caption + spacing
                                }
                            }

                            // If we don't have room for header plus at least first image, start new page
                            if (yOffset + headerHeight + firstImageHeight > pageHeight - 40) {
                                doc.addPage();
                                yOffset = 20;
                            }
                            
                            // Measure the space needed for first image
                            let imageHeight = 0;
                            if (images[0]) {
                                const imageData = await loadImage(images[0]);
                                if (imageData) {
                                    const imgElement = new Image();
                                    await new Promise((resolve) => {
                                        imgElement.onload = resolve;
                                        imgElement.src = imageData;
                                    });

                                    let finalWidth = imgElement.width;
                                    let finalHeight = imgElement.height;
                                    const maxWidth = doc.internal.pageSize.width - (margin * 2);
                                    const maxHeight = 120;

                                    if (finalWidth > maxWidth) {
                                        const ratio = maxWidth / finalWidth;
                                        finalWidth = maxWidth;
                                        finalHeight = finalHeight * ratio;
                                    }

                                    if (finalHeight > maxHeight) {
                                        const ratio = maxHeight / finalHeight;
                                        finalHeight = maxHeight;
                                    }

                                    imageHeight = finalHeight + 25; // image height + caption + spacing
                                }
                            }

                            const totalNeededHeight = headerHeight + imageHeight;
                            
                            // Start a new page if we don't have enough space for both header and first image
                            if (yOffset + totalNeededHeight > pageHeight - 40) {
                                doc.addPage();
                                yOffset = 20;
                            }

                            // Process all images
                            for (const img of images) {
                                await processImage({
                                    ...img,
                                    caption: getCaption(img),
                                });
                            }
                        };

                        // Prepare all image arrays first
                        const allTypeImages = typeSpecimens?.flatMap(ts => 
                            ts.Specimen?.images?.map(img => ({
                                ...img,
                                specimenName: ts.Specimen.name
                            })) || []
                        ) || [];

                        const allIdentifiedImages = identifiedSpecimens?.flatMap(is => 
                            is.Specimen?.images?.map(img => ({
                                ...img,
                                specimenName: is.Specimen.name
                            })) || []
                        ) || [];

                        // Calculate total height needed for main header and first section
                        const firstSectionTitle = holotypeImages.length > 0 ? "Holotype Images" :
                            allTypeImages.length > 0 ? "Other Type Images" : "Identified Specimen Images";
                        const firstSectionImages = holotypeImages.length > 0 ? holotypeImages :
                            allTypeImages.length > 0 ? allTypeImages : allIdentifiedImages;
                        
                        if (firstSectionImages.length > 0) {
                            // Calculate space needed for first image
                            let firstImageHeight = 0;
                            if (firstSectionImages[0]) {
                                const imageData = await loadImage(firstSectionImages[0]);
                                if (imageData) {
                                    const imgElement = new Image();
                                    await new Promise((resolve) => {
                                        imgElement.onload = resolve;
                                        imgElement.src = imageData;
                                    });

                                    let finalWidth = imgElement.width;
                                    let finalHeight = imgElement.height;
                                    const maxWidth = doc.internal.pageSize.width - (margin * 2);
                                    const maxHeight = 120;

                                    if (finalWidth > maxWidth) {
                                        const ratio = maxWidth / finalWidth;
                                        finalWidth = maxWidth;
                                        finalHeight = finalHeight * ratio;
                                    }

                                    if (finalHeight > maxHeight) {
                                        const ratio = maxHeight / finalHeight;
                                        finalHeight = maxHeight;
                                    }

                                    firstImageHeight = finalHeight + 25; // image height + caption + spacing
                                }
                            }

                            const mainHeaderHeight = 25;
                            const subHeaderHeight = 25;
                            const totalNeededHeight = mainHeaderHeight + subHeaderHeight + firstImageHeight;
                            const pageHeight = doc.internal.pageSize.height;
                            
                            // Check if we need a new page for main header + first section
                            if (yOffset + totalNeededHeight > pageHeight - 40) {
                                doc.addPage();
                                yOffset = 20;
                            }
                            
                            // Add main Images header
                            doc.setFontSize(styles.subtitle.fontSize);
                            doc.text("Images", margin, yOffset);
                            yOffset += 15;
                            doc.setFontSize(styles.text.fontSize);
                        }

                        // Process each section
                        // Holotype Images Section
                        await processImageSection(
                            "Holotype Images",
                            holotypeImages,
                            img => `${holotypeSpecimen.Specimen.name} - ${img.caption}`
                        );

                        // Other Type Images Section
                        if (holotypeImages.length > 0) yOffset += 10;
                        if (allTypeImages.length > 0) {
                            await processImageSection(
                                "Other Type Images",
                                allTypeImages,
                                img => `${img.specimenName} - ${img.caption}`
                            );
                        }

                        // Identified Specimen Images Section
                        if (holotypeImages.length > 0 || typeImages.length > 0) yOffset += 10;
                        
                        if (allIdentifiedImages.length > 0) {
                            await processImageSection(
                                "Identified Specimen Images",
                                allIdentifiedImages,
                                img => `${img.specimenName} - ${img.caption}`
                            );
                        }

                        yOffset += 10;
                    }

                    // 2. Taxonomy Section
                    if (yOffset > doc.internal.pageSize.height - 40) {
                        doc.addPage();
                        yOffset = 20;
                    }

                    doc.setFontSize(styles.subtitle.fontSize);
                    doc.text("Taxonomy", margin, yOffset);
                    yOffset += 15;
                    doc.setFontSize(styles.text.fontSize);

                    doc.text(`Major Taxon Group: ${majorTaxonGroup || "N/A"}`, margin, yOffset);
                    yOffset += 10;
                    doc.text(`Family: ${family || "N/A"}`, margin, yOffset);
                    yOffset += 10;
                    doc.text(`Genus: ${genus || "N/A"}`, margin, yOffset);
                    yOffset += 10;
                    doc.text(`Species: ${species || "N/A"}`, margin, yOffset);
                    yOffset += 10;
                    doc.text(`Parent Taxon: ${pbdbParentTaxon || "N/A"}`, margin, yOffset);
                    yOffset += 20;

                    // 3. Diagnosis Section
                    if (yOffset > doc.internal.pageSize.height - 40) {
                        doc.addPage();
                        yOffset = 20;
                    }
                    
                    doc.setFontSize(styles.subtitle.fontSize);
                    doc.text("Diagnosis", margin, yOffset);
                    yOffset += 15;
                    doc.setFontSize(styles.text.fontSize);
                    
                    if (diagnosis) {
                        const diagnosisLines = doc.splitTextToSize(diagnosis, doc.internal.pageSize.width - (margin * 2));
                        doc.text(diagnosisLines, margin, yOffset);
                        yOffset += (diagnosisLines.length * 7) + 10;
                    } else {
                        doc.text("No diagnosis available", margin, yOffset);
                        yOffset += 10;
                    }

                    // 4. Holotype Descriptions Section
                    if (yOffset > doc.internal.pageSize.height - 40) {
                        doc.addPage();
                        yOffset = 20;
                    }

                    doc.setFontSize(styles.subtitle.fontSize);
                    doc.text("Holotype Descriptions", margin, yOffset);
                    yOffset += 15;
                    doc.setFontSize(styles.text.fontSize);

                    if (holotypeSpecimen?.Specimen?.describedBy) {
                        holotypeSpecimen.Specimen.describedBy.forEach(desc => {
                            doc.text(`Schema: ${desc.Description.schema.title}`, margin, yOffset);
                            yOffset += 10;

                            if (desc.Description.writtenDescription) {
                                doc.text("Written Description:", margin + 10, yOffset);
                                yOffset += 5;
                                const descLines = doc.splitTextToSize(
                                    desc.Description.writtenDescription,
                                    doc.internal.pageSize.width - (margin * 3)
                                );
                                doc.text(descLines, margin + 10, yOffset);
                                yOffset += (descLines.length * 7) + 5;
                            }

                            if (desc.Description.characterInstances?.length > 0) {
                                doc.text("Character States:", margin + 10, yOffset);
                                yOffset += 5;
                                desc.Description.characterInstances.forEach(ci => {
                                    const stateText = `${ci.character.name}: ${ci.state.State.name}`;
                                    doc.text(stateText, margin + 20, yOffset);
                                    yOffset += 7;
                                });
                            }

                            if (desc.Description.notes) {
                                doc.text("Notes:", margin + 10, yOffset);
                                yOffset += 5;
                                const noteLines = doc.splitTextToSize(
                                    desc.Description.notes,
                                    doc.internal.pageSize.width - (margin * 3)
                                );
                                doc.text(noteLines, margin + 10, yOffset);
                                yOffset += (noteLines.length * 7) + 5;
                            }
                            yOffset += 10;
                        });
                    } else {
                        doc.text("No holotype descriptions available", margin, yOffset);
                        yOffset += 10;
                    }

                    // 5. Merged Descriptions Section
                    if (yOffset > doc.internal.pageSize.height - 40) {
                        doc.addPage();
                        yOffset = 20;
                    }

                    doc.setFontSize(styles.subtitle.fontSize);
                    doc.text("Merged Descriptions", margin, yOffset);
                    yOffset += 15;
                    doc.setFontSize(styles.text.fontSize);

                    if (mergedDescription?.length > 0) {
                        const schemas = mergedDescription.reduce((acc, ci) => 
                            acc.includes(ci.schema) ? acc : acc.concat(ci.schema), []);
                        
                        schemas.forEach(schema => {
                            doc.text(`Schema: ${schema}`, margin, yOffset);
                            yOffset += 10;
                            doc.text("Character States:", margin + 10, yOffset);
                            yOffset += 5;

                            const schemaDescriptions = mergedDescription
                                .filter(ci => ci.schema === schema)
                                .map(ci => {
                                    const value = ci.stateName === "quantity" ? ci.stateValue : ci.stateName;
                                    const order = ci.stateOrder ? `, order: ${ci.stateOrder}` : '';
                                    return `${ci.characterName}: ${value}${order}`;
                            });
                        
                            schemaDescriptions.forEach(desc => {
                                const descLines = doc.splitTextToSize(desc, doc.internal.pageSize.width - (margin * 3));
                                doc.text(descLines, margin + 20, yOffset);
                                yOffset += (descLines.length * 7) + 3;
                            });
                            yOffset += 10;
                        });
                    } else {
                        doc.text("No merged descriptions available", margin, yOffset);
                        yOffset += 10;
                    }

                    // 6. Exemplar Specimens Section
                    if (yOffset > doc.internal.pageSize.height - 40) {
                        doc.addPage();
                        yOffset = 20;
                    }

                    doc.setFontSize(styles.subtitle.fontSize);
                    doc.text("Exemplar Specimens", margin, yOffset);
                    yOffset += 15;
                    doc.setFontSize(styles.text.fontSize);

                    // Holotype specimen details
                    if (holotypeSpecimen?.Specimen) {
                        doc.text("Holotype Specimen:", margin, yOffset);
                        yOffset += 10;
                        doc.text(`ID: ${holotypeSpecimen.Specimen.pbotID}`, margin + 10, yOffset);
                        yOffset += 7;
                        doc.text(`Name: ${holotypeSpecimen.Specimen.name}`, margin + 10, yOffset);
                        yOffset += 7;
                        if (holotypeSpecimen.Specimen.collection) {
                            doc.text(`Collection: ${holotypeSpecimen.Specimen.collection.name}`, margin + 10, yOffset);
                            yOffset += 7;
                            doc.text(`Country: ${holotypeSpecimen.Specimen.collection.country || "N/A"}`, margin + 10, yOffset);
                            yOffset += 7;
                            doc.text(`Min Interval: ${holotypeSpecimen.Specimen.collection.mininterval || "N/A"}`, margin + 10, yOffset);
                            yOffset += 7;
                            doc.text(`Max Interval: ${holotypeSpecimen.Specimen.collection.maxinterval || "N/A"}`, margin + 10, yOffset);
                            yOffset += 10;
                        }
                    }

                    // Other type specimens
                    if (typeSpecimens?.length > 0) {
                        doc.text("Other Type Specimens:", margin, yOffset);
                        yOffset += 10;
                        typeSpecimens.forEach(ts => {
                            if (ts.Specimen) {
                                doc.text(`ID: ${ts.Specimen.pbotID}`, margin + 10, yOffset);
                                yOffset += 7;
                                doc.text(`Name: ${ts.Specimen.name}`, margin + 10, yOffset);
                                yOffset += 7;
                                if (ts.Specimen.collection) {
                                    doc.text(`Collection: ${ts.Specimen.collection.name}`, margin + 10, yOffset);
                                    yOffset += 7;
                                    doc.text(`Country: ${ts.Specimen.collection.country || "N/A"}`, margin + 10, yOffset);
                                    yOffset += 7;
                                    doc.text(`Min/Max Interval: ${ts.Specimen.collection.mininterval || "N/A"} - ${ts.Specimen.collection.maxinterval || "N/A"}`, margin + 10, yOffset);
                                    yOffset += 10;
                                }
                            }
                        });
                    }

                    // Additional specimens
                    if (identifiedSpecimens?.length > 0) {
                        doc.text("Additional Specimens:", margin, yOffset);
                        yOffset += 10;
                        identifiedSpecimens.forEach(is => {
                            if (is.Specimen) {
                                doc.text(`ID: ${is.Specimen.pbotID}`, margin + 10, yOffset);
                                yOffset += 7;
                                doc.text(`Name: ${is.Specimen.name}`, margin + 10, yOffset);
                                yOffset += 7;
                                if (is.Specimen.collection) {
                                    doc.text(`Collection: ${is.Specimen.collection.name}`, margin + 10, yOffset);
                                    yOffset += 7;
                                    doc.text(`Country: ${is.Specimen.collection.country || "N/A"}`, margin + 10, yOffset);
                                    yOffset += 7;
                                    doc.text(`Min/Max Interval: ${is.Specimen.collection.mininterval || "N/A"} - ${is.Specimen.collection.maxinterval || "N/A"}`, margin + 10, yOffset);
                                    yOffset += 10;
                                }
                            }
                        });
                    }

                    // 7. Notes Section
                    if (yOffset > doc.internal.pageSize.height - 40) {
                        doc.addPage();
                        yOffset = 20;
                    }

                    doc.setFontSize(styles.subtitle.fontSize);
                    doc.text("Notes", margin, yOffset);
                    yOffset += 15;
                    doc.setFontSize(styles.text.fontSize);

                    if (notes) {
                        const noteLines = doc.splitTextToSize(notes, doc.internal.pageSize.width - (margin * 2));
                        doc.text(noteLines, margin, yOffset);
                        yOffset += (noteLines.length * 7) + 10;
                    } else {
                        doc.text("No notes available", margin, yOffset);
                        yOffset += 10;
                    }

                    // 8. Synonyms Section
                    if (yOffset > doc.internal.pageSize.height - 40) {
                        doc.addPage();
                        yOffset = 20;
                    }

                    doc.setFontSize(styles.subtitle.fontSize);
                    doc.text("Synonyms", margin, yOffset);
                    yOffset += 15;
                    doc.setFontSize(styles.text.fontSize);

                    if (synonyms?.length > 0) {
                        synonyms.forEach(synonym => {
                            const synOTU = synonym.otus.filter(synOtu => synOtu.pbotID !== pbotID)[0];
                            if (synOTU) {
                                doc.text(synOTU.name, margin, yOffset);
                                yOffset += 7;
                                if (synOTU.family) {
                                    doc.text(`Family: ${synOTU.family}`, margin + 10, yOffset);
                                    yOffset += 7;
                                }
                                if (synOTU.genus) {
                                    doc.text(`Genus: ${synOTU.genus}`, margin + 10, yOffset);
                                    yOffset += 7;
                                }
                                if (synOTU.species) {
                                    doc.text(`Species: ${synOTU.species}`, margin + 10, yOffset);
                                    yOffset += 7;
                                }
                                if (synonym.explanation) {
                                    doc.text("Explanation:", margin + 10, yOffset);
                                    yOffset += 5;
                                    const expLines = doc.splitTextToSize(
                                        synonym.explanation,
                                        doc.internal.pageSize.width - (margin * 3)
                                    );
                                    doc.text(expLines, margin + 10, yOffset);
                                    yOffset += (expLines.length * 7) + 5;
                                }
                                if (synonym.references?.length > 0) {
                                    doc.text("References:", margin + 10, yOffset);
                                    yOffset += 5;
                                    synonym.references.forEach(ref => {
                                        doc.text(ref.Reference.title, margin + 20, yOffset);
                                        yOffset += 7;
                                    });
                                }
                                yOffset += 10;
                            }
                        });
                    } else {
                        doc.text("No synonyms available", margin, yOffset);
                        yOffset += 10;
                    }

                    // 9. History Section
                    if (yOffset > doc.internal.pageSize.height - 40) {
                        doc.addPage();
                        yOffset = 20;
                    }

                    doc.setFontSize(styles.subtitle.fontSize);
                    doc.text("History", margin, yOffset);
                    yOffset += 15;
                    doc.setFontSize(styles.text.fontSize);

                    if (enteredBy?.length > 0) {
                        const history = sort(enteredBy.map(e => ({
                            timestamp: e.timestamp.formatted,
                            type: e.type,
                            person: `${e.Person.given}${e.Person.middle ? ` ${e.Person.middle}` : ''} ${e.Person.surname}`
                        })), "timestamp");

                        history.forEach(entry => {
                            const text = `${entry.timestamp} - ${entry.type} - ${entry.person}`;
                            doc.text(text, margin, yOffset);
                            yOffset += 7;
                        });
                    } else {
                        doc.text("No history available", margin, yOffset);
                        yOffset += 10;
                    }
                }

                // Save the PDF after all processing is complete
                doc.save("otu-report.pdf");
                setPdfGenerated(true);
            }
        };

        // Execute the async function and reset the state
        setPdfGenerated(false);
        generatePDF().catch((error) => {
            console.error(error);
            setPdfGenerated(false);
        });
    }, [otus, pdfGenerated]);

    return (
        <div style={{ padding: 20 }}>
            {otus.length > 0 ? (
                pdfGenerated ? (
                    <p>PDF has been generated and downloaded.</p>
                ) : (
                    <p>Generating PDF...</p>
                )
            ) : (
                <p>No data available to generate PDF.</p>
            )}
        </div>
    );
};
